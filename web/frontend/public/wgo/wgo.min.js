!(function (t, i) {
  "use strict";
  var e = document.getElementsByTagName("script"),
    s = {
      version: "2.3.1",
      B: 1,
      W: -1,
      ERROR_REPORT: !0,
      DIR:
        e[e.length - 1].src.split("?")[0].split("/").slice(0, -1).join("/") +
        "/",
      lang: "en",
      i18n: { en: {} },
    };
  (s.opera =
    -1 != navigator.userAgent.search(/(opera)(?:.*version)?[ \/]([\w.]+)/i)),
    (s.webkit = -1 != navigator.userAgent.search(/(webkit)[ \/]([\w.]+)/i)),
    (s.msie = -1 != navigator.userAgent.search(/(msie) ([\w.]+)/i)),
    (s.mozilla =
      -1 != navigator.userAgent.search(/(mozilla)(?:.*? rv:([\w.]+))?/i) &&
      !s.webkit &&
      !s.msie),
    (s.t = function (t) {
      var i = s.i18n[s.lang][t] || s.i18n.en[t];
      if (i) {
        for (var e = 1; e < arguments.length; e++)
          i = i.replace("$", arguments[e]);
        return i;
      }
      return t;
    }),
    (s.extendClass = function (t, i) {
      return (
        (i.prototype = Object.create(t.prototype)),
        (i.prototype.constructor = i),
        (i.prototype.super = t),
        i
      );
    }),
    (s.abstractMethod = function () {
      throw Error("unimplemented abstract method");
    }),
    (s.clone = function (t) {
      if (t && "object" == typeof t) {
        var i = t.constructor == Array ? [] : {};
        for (var e in t) t[e] == t ? (i[e] = t) : (i[e] = s.clone(t[e]));
        return i;
      }
      return t;
    }),
    (s.filterHTML = function (t) {
      return t && "string" == typeof t
        ? t.replace(/</g, "&lt;").replace(/>/g, "&gt;")
        : t;
    });
  var o = function (i, e) {
    e = e || {};
    for (var n in e) this[n] = e[n];
    for (var n in s.Board.default)
      void 0 === this[n] && (this[n] = s.Board.default[n]);
    for (var n in o.themes.default)
      void 0 === this.theme[n] && (this.theme[n] = o.themes.default[n]);
    (this.tx = this.section.left),
      (this.ty = this.section.top),
      (this.bx = this.size - 1 - this.section.right),
      (this.by = this.size - 1 - this.section.bottom),
      this.init(),
      i.appendChild(this.element),
      (this.pixelRatio = t.devicePixelRatio || 1),
      this.width && this.height
        ? this.setDimensions(this.width, this.height)
        : this.width
        ? this.setWidth(this.width)
        : this.height && this.setHeight(this.height);
  };
  (o.themes = {}),
    (o.themes.old = {
      shadowColor: "rgba(32,32,32,0.5)",
      shadowTransparentColor: "rgba(32,32,32,0)",
      shadowBlur: 0,
      shadowSize: function (t) {
        return t.shadowSize;
      },
      markupBlackColor: "rgba(255,255,255,0.8)",
      markupWhiteColor: "rgba(0,0,0,0.8)",
      markupNoneColor: "rgba(0,0,0,0.8)",
      markupLinesWidth: function (t) {
        return t.autoLineWidth ? t.stoneRadius / 7 : t.lineWidth;
      },
      gridLinesWidth: 1,
      gridLinesColor: function (t) {
        return "rgba(0,0,0," + Math.min(1, t.stoneRadius / 15) + ")";
      },
      starColor: "#000",
      starSize: function (t) {
        return t.starSize * (t.width / 300 + 1);
      },
      stoneSize: function (t) {
        return (t.stoneSize * Math.min(t.fieldWidth, t.fieldHeight)) / 2;
      },
      coordinatesColor: "rgba(0,0,0,0.7)",
      font: function (t) {
        return t.font;
      },
      linesShift: 0.5,
    }),
    (o.themes.default = {
      shadowColor: "rgba(62,32,32,0.5)",
      shadowTransparentColor: "rgba(62,32,32,0)",
      shadowBlur: function (t) {
        return 0.1 * t.stoneRadius;
      },
      shadowSize: 1,
      markupBlackColor: "rgba(255,255,255,0.9)",
      markupWhiteColor: "rgba(0,0,0,0.7)",
      markupNoneColor: "rgba(0,0,0,0.7)",
      markupLinesWidth: function (t) {
        return t.stoneRadius / 8;
      },
      gridLinesWidth: function (t) {
        return t.stoneRadius / 15;
      },
      gridLinesColor: "#654525",
      starColor: "#531",
      starSize: function (t) {
        return t.stoneRadius / 8 + 1;
      },
      stoneSize: function (t) {
        return Math.min(t.fieldWidth, t.fieldHeight) / 2;
      },
      coordinatesColor: "#531",
      variationColor: "rgba(0,32,128,0.8)",
      font: "calibri",
      linesShift: 0.25,
    });
  var n,
    h = function (t, i) {
      return "function" == typeof i.theme[t] ? i.theme[t](i) : i.theme[t];
    },
    a = {
      draw: function (t, i) {
        var e = i.getX(t.x),
          s = i.getY(t.y),
          o = i.stoneRadius;
        this.beginPath();
        var n = h("shadowBlur", i),
          a = Math.max(0, o - 0.5),
          r = this.createRadialGradient(
            e - i.ls,
            s - i.ls,
            a - 1 - n,
            e - i.ls,
            s - i.ls,
            a + n
          );
        r.addColorStop(0, h("shadowColor", i)),
          r.addColorStop(1, h("shadowTransparentColor", i)),
          (this.fillStyle = r),
          this.arc(e - i.ls, s - i.ls, a + n, 0, 2 * Math.PI, !0),
          this.fill();
      },
      clear: function (t, i) {
        var e = i.getX(t.x),
          s = i.getY(t.y),
          o = i.stoneRadius;
        this.clearRect(
          e - 1.1 * o - i.ls,
          s - 1.1 * o - i.ls,
          2.2 * o,
          2.2 * o
        );
      },
    },
    r = {
      draw: function (t, i) {
        var e = i.getX(t.x),
          s = i.getY(t.y),
          o = i.stoneRadius;
        this.beginPath();
        var n = Math.max(0, 0.85 * (o - 0.5)),
          a = this.createRadialGradient(
            e - 1,
            s - -5,
            n - 1 - 5,
            e - 1,
            s - -5,
            n + 5
          );
        a.addColorStop(0, h("shadowColor", i)),
          a.addColorStop(1, h("shadowTransparentColor", i)),
          (this.fillStyle = a),
          this.arc(e - 1, s - -5, n + 5, 0, 2 * Math.PI, !0),
          this.fill();
      },
      clear: function (t, i) {
        var e = i.getX(t.x),
          s = i.getY(t.y),
          o = i.stoneRadius;
        this.clearRect(e - 1.1 * o - 1, s - 1.1 * o - -5, 2.2 * o, 2.2 * o);
      },
    },
    l = function (t, i, e) {
      return t.obj_arr[i][e][0].c == s.B
        ? h("markupBlackColor", t)
        : t.obj_arr[i][e][0].c == s.W
        ? h("markupWhiteColor", t)
        : h("markupNoneColor", t);
    },
    c = function (t, i, e) {
      return (
        (t.obj_arr[i][e][0] && t.obj_arr[i][e][0].c == s.W) ||
        t.obj_arr[i][e][0].c == s.B
      );
    },
    d = function (t, i, e, s, o, n, h, a) {
      (t.strokeStyle = "rgba(64,64,64,0.2)"),
        (t.lineWidth = (s / 30) * a),
        t.beginPath();
      var r,
        l,
        c,
        d,
        u = i + (s -= Math.max(1, t.lineWidth)) * Math.cos(o * Math.PI),
        f = e + s * Math.sin(o * Math.PI),
        p = i + s * Math.cos(n * Math.PI),
        g = e + s * Math.sin(n * Math.PI);
      p > u
        ? ((r = (g - f) / (p - u)), (l = Math.atan(r)))
        : p == u
        ? (l = Math.PI / 2)
        : ((r = (g - f) / (p - u)), (l = Math.atan(r) - Math.PI));
      var y = h * s,
        x = u + (c = Math.sin(l) * y),
        m = f - (d = Math.cos(l) * y),
        v = p + c,
        b = g - d;
      t.moveTo(u, f), t.bezierCurveTo(x, m, v, b, p, g), t.stroke();
    },
    u = function (t) {
      for (var i = t.angle, e = t.angle, s = 0; s < t.lines.length; s++)
        (i += t.lines[s]),
          (e -= t.lines[s]),
          d(t.ctx, t.x, t.y, t.radius, i, e, t.factor, t.thickness);
    };
  (o.drawHandlers = {
    NORMAL: {
      stone: {
        draw: function (t, i) {
          var e,
            o = i.getX(t.x),
            n = i.getY(t.y),
            h = i.stoneRadius;
          t.c == s.W
            ? ((e = this.createRadialGradient(
                o - (2 * h) / 5,
                n - (2 * h) / 5,
                h / 3,
                o - h / 5,
                n - h / 5,
                (5 * h) / 5
              )).addColorStop(0, "#fff"),
              e.addColorStop(1, "#aaa"))
            : ((e = this.createRadialGradient(
                o - (2 * h) / 5,
                n - (2 * h) / 5,
                1,
                o - h / 5,
                n - h / 5,
                (4 * h) / 5
              )).addColorStop(0, "#666"),
              e.addColorStop(1, "#000")),
            this.beginPath(),
            (this.fillStyle = e),
            this.arc(
              o - i.ls,
              n - i.ls,
              Math.max(0, h - 0.5),
              0,
              2 * Math.PI,
              !0
            ),
            this.fill();
        },
      },
      shadow: a,
    },
    PAINTED: {
      stone: {
        draw: function (t, i) {
          var e,
            o = i.getX(t.x),
            n = i.getY(t.y),
            h = i.stoneRadius;
          t.c == s.W
            ? ((e = this.createRadialGradient(
                o - (2 * h) / 5,
                n - (2 * h) / 5,
                2,
                o - h / 5,
                n - h / 5,
                (4 * h) / 5
              )).addColorStop(0, "#fff"),
              e.addColorStop(1, "#ddd"))
            : ((e = this.createRadialGradient(
                o - (2 * h) / 5,
                n - (2 * h) / 5,
                1,
                o - h / 5,
                n - h / 5,
                (4 * h) / 5
              )).addColorStop(0, "#111"),
              e.addColorStop(1, "#000")),
            this.beginPath(),
            (this.fillStyle = e),
            this.arc(
              o - i.ls,
              n - i.ls,
              Math.max(0, h - 0.5),
              0,
              2 * Math.PI,
              !0
            ),
            this.fill(),
            this.beginPath(),
            (this.lineWidth = h / 6),
            t.c == s.W
              ? ((this.strokeStyle = "#999"),
                this.arc(o + h / 8, n + h / 8, h / 2, 0, Math.PI / 2, !1))
              : ((this.strokeStyle = "#ccc"),
                this.arc(o - h / 8, n - h / 8, h / 2, Math.PI, 1.5 * Math.PI)),
            this.stroke();
        },
      },
      shadow: a,
    },
    REALISTIC: {
      stone: {
        draw: function (t, i) {
          var e = i.getX(t.x),
            n = i.getY(t.y),
            h = i.stoneRadius,
            a = i.whiteStoneGraphic.length,
            r = i.blackStoneGraphic.length;
          void 0 === this.randIndex &&
            (this.randIndex = Math.ceil(1e5 * Math.random()));
          var l = function () {
              i.redraw();
            },
            c = function (t) {
              return (
                "string" != typeof t &&
                !!t.complete &&
                (void 0 === t.naturalWidth || 0 != t.naturalWidth)
              );
            };
          if (t.c == s.W) {
            var d = this.randIndex % a;
            if ("string" == typeof i.whiteStoneGraphic[d])
              ((u = new Image()).onload = l),
                (u.src = i.whiteStoneGraphic[d]),
                (i.whiteStoneGraphic[d] = u);
            c(i.whiteStoneGraphic[d])
              ? this.drawImage(
                  i.whiteStoneGraphic[d],
                  e - h,
                  n - h,
                  2 * h,
                  2 * h
                )
              : o.drawHandlers.SHELL.stone.draw.call(this, t, i);
          } else {
            var u;
            d = this.randIndex % r;
            if ("string" == typeof i.blackStoneGraphic[d])
              ((u = new Image()).onload = l),
                (u.src = i.blackStoneGraphic[d]),
                (i.blackStoneGraphic[d] = u);
            c(i.blackStoneGraphic[d])
              ? this.drawImage(
                  i.blackStoneGraphic[d],
                  e - h,
                  n - h,
                  2 * h,
                  2 * h
                )
              : o.drawHandlers.SHELL.stone.draw.call(this, t, i);
          }
        },
      },
      shadow: r,
    },
    GLOW: {
      stone: {
        draw: function (t, i) {
          var e,
            o = i.getX(t.x),
            n = i.getY(t.y),
            h = i.stoneRadius;
          t.c == s.W
            ? ((e = this.createRadialGradient(
                o - (2 * h) / 5,
                n - (2 * h) / 5,
                h / 3,
                o - h / 5,
                n - h / 5,
                (8 * h) / 5
              )).addColorStop(0, "#fff"),
              e.addColorStop(1, "#666"))
            : ((e = this.createRadialGradient(
                o - (2 * h) / 5,
                n - (2 * h) / 5,
                1,
                o - h / 5,
                n - h / 5,
                (3 * h) / 5
              )).addColorStop(0, "#555"),
              e.addColorStop(1, "#000")),
            this.beginPath(),
            (this.fillStyle = e),
            this.arc(
              o - i.ls,
              n - i.ls,
              Math.max(0, h - 0.5),
              0,
              2 * Math.PI,
              !0
            ),
            this.fill();
        },
      },
      shadow: a,
    },
    SHELL: {
      stone: {
        draw: function (t, i) {
          var e,
            o,
            h,
            a = i.stoneRadius;
          if (
            ((n = n || Math.ceil(9999999 * Math.random())),
            (e = i.getX(t.x)),
            (o = i.getY(t.y)),
            (h = t.c == s.W ? "#aaa" : "#000"),
            this.beginPath(),
            (this.fillStyle = h),
            this.arc(
              e - i.ls,
              o - i.ls,
              Math.max(0, a - 0.5),
              0,
              2 * Math.PI,
              !0
            ),
            this.fill(),
            t.c == s.W)
          ) {
            var r = (n % (3 + t.x * i.size + t.y)) % 3,
              l = i.size * i.size + t.x * i.size + t.y,
              c = (2 / l) * (n % l);
            u(
              0 == r
                ? {
                    ctx: this,
                    x: e,
                    y: o,
                    radius: a,
                    angle: c,
                    lines: [0.1, 0.12, 0.11, 0.1, 0.09, 0.09, 0.09, 0.09],
                    factor: 0.25,
                    thickness: 1.75,
                  }
                : 1 == r
                ? {
                    ctx: this,
                    x: e,
                    y: o,
                    radius: a,
                    angle: c,
                    lines: [
                      0.1, 0.09, 0.08, 0.07, 0.06, 0.06, 0.06, 0.06, 0.06, 0.06,
                      0.06,
                    ],
                    factor: 0.2,
                    thickness: 1.5,
                  }
                : {
                    ctx: this,
                    x: e,
                    y: o,
                    radius: a,
                    angle: c,
                    lines: [0.12, 0.14, 0.13, 0.12, 0.12, 0.12],
                    factor: 0.3,
                    thickness: 2,
                  }
            ),
              (h = this.createRadialGradient(
                e - (2 * a) / 5,
                o - (2 * a) / 5,
                a / 3,
                e - a / 5,
                o - a / 5,
                (5 * a) / 5
              )).addColorStop(0, "rgba(255,255,255,0.9)"),
              h.addColorStop(1, "rgba(255,255,255,0)"),
              this.beginPath(),
              (this.fillStyle = h),
              this.arc(
                e - i.ls,
                o - i.ls,
                Math.max(0, a - 0.5),
                0,
                2 * Math.PI,
                !0
              ),
              this.fill();
          } else
            (h = this.createRadialGradient(
              e + 0.4 * a,
              o + 0.4 * a,
              0,
              e + 0.5 * a,
              o + 0.5 * a,
              a
            )).addColorStop(0, "rgba(32,32,32,1)"),
              h.addColorStop(1, "rgba(0,0,0,0)"),
              this.beginPath(),
              (this.fillStyle = h),
              this.arc(
                e - i.ls,
                o - i.ls,
                Math.max(0, a - 0.5),
                0,
                2 * Math.PI,
                !0
              ),
              this.fill(),
              (h = this.createRadialGradient(
                e - 0.4 * a,
                o - 0.4 * a,
                1,
                e - 0.5 * a,
                o - 0.5 * a,
                1.5 * a
              )).addColorStop(0, "rgba(64,64,64,1)"),
              h.addColorStop(1, "rgba(0,0,0,0)"),
              this.beginPath(),
              (this.fillStyle = h),
              this.arc(
                e - i.ls,
                o - i.ls,
                Math.max(0, a - 0.5),
                0,
                2 * Math.PI,
                !0
              ),
              this.fill();
        },
      },
      shadow: a,
    },
    MONO: {
      stone: {
        draw: function (t, i) {
          var e = i.getX(t.x),
            o = i.getY(t.y),
            n = i.stoneRadius,
            a = h("markupLinesWidth", i) || 1;
          t.c == s.W ? (this.fillStyle = "white") : (this.fillStyle = "black"),
            this.beginPath(),
            this.arc(e, o, Math.max(0, n - a), 0, 2 * Math.PI, !0),
            this.fill(),
            (this.lineWidth = a),
            (this.strokeStyle = "black"),
            this.stroke();
        },
      },
    },
    CR: {
      stone: {
        draw: function (t, i) {
          var e = i.getX(t.x),
            s = i.getY(t.y),
            o = i.stoneRadius;
          (this.strokeStyle = t.c || l(i, t.x, t.y)),
            (this.lineWidth = t.lineWidth || h("markupLinesWidth", i) || 1),
            this.beginPath(),
            this.arc(e - i.ls, s - i.ls, o / 2, 0, 2 * Math.PI, !0),
            this.stroke();
        },
      },
    },
    LB: {
      stone: {
        draw: function (t, i) {
          var e = i.getX(t.x),
            s = i.getY(t.y),
            o = i.stoneRadius,
            n = t.font || h("font", i) || "";
          (this.fillStyle = t.c || l(i, t.x, t.y)),
            1 == t.text.length
              ? (this.font = Math.round(1.5 * o) + "px " + n)
              : 2 == t.text.length
              ? (this.font = Math.round(1.2 * o) + "px " + n)
              : (this.font = Math.round(o) + "px " + n),
            this.beginPath(),
            (this.textBaseline = "middle"),
            (this.textAlign = "center"),
            this.fillText(t.text, e, s, 2 * o);
        },
      },
      grid: {
        draw: function (t, i) {
          if (!c(i, t.x, t.y) && !t._nodraw) {
            var e = i.getX(t.x),
              s = i.getY(t.y),
              o = i.stoneRadius;
            this.clearRect(e - o, s - o, 2 * o, 2 * o);
          }
        },
        clear: function (t, i) {
          c(i, t.x, t.y) ||
            ((t._nodraw = !0),
            (function (t, i) {
              t[i].clear(), t[i].draw(t);
              for (var e = 0; e < t.size; e++)
                for (var s = 0; s < t.size; s++)
                  for (var n = 0; n < t.obj_arr[e][s].length; n++)
                    (r = (a = t.obj_arr[e][s][n]).type
                      ? "string" == typeof a.type
                        ? o.drawHandlers[a.type]
                        : a.type
                      : t.stoneHandler)[i] &&
                      r[i].draw.call(t[i].getContext(a), a, t);
              for (var h = 0; h < t.obj_list.length; h++) {
                var a, r;
                (r = (a = t.obj_list[h]).handler)[i] &&
                  r[i].draw.call(t[i].getContext(a.args), a.args, t);
              }
            })(i, "grid"),
            delete t._nodraw);
        },
      },
    },
    SQ: {
      stone: {
        draw: function (t, i) {
          var e = i.getX(t.x),
            s = i.getY(t.y),
            o = Math.round(i.stoneRadius);
          (this.strokeStyle = t.c || l(i, t.x, t.y)),
            (this.lineWidth = t.lineWidth || h("markupLinesWidth", i) || 1),
            this.beginPath(),
            this.rect(
              Math.round(e - o / 2) - i.ls,
              Math.round(s - o / 2) - i.ls,
              o,
              o
            ),
            this.stroke();
        },
      },
    },
    TR: {
      stone: {
        draw: function (t, i) {
          var e = i.getX(t.x),
            s = i.getY(t.y),
            o = i.stoneRadius;
          (this.strokeStyle = t.c || l(i, t.x, t.y)),
            (this.lineWidth = t.lineWidth || h("markupLinesWidth", i) || 1),
            this.beginPath(),
            this.moveTo(e - i.ls, s - i.ls - Math.round(o / 2)),
            this.lineTo(
              Math.round(e - o / 2) - i.ls,
              Math.round(s + o / 3) + i.ls
            ),
            this.lineTo(
              Math.round(e + o / 2) + i.ls,
              Math.round(s + o / 3) + i.ls
            ),
            this.closePath(),
            this.stroke();
        },
      },
    },
    MA: {
      stone: {
        draw: function (t, i) {
          var e = i.getX(t.x),
            s = i.getY(t.y),
            o = i.stoneRadius;
          (this.strokeStyle = t.c || l(i, t.x, t.y)),
            (this.lineCap = "round"),
            (this.lineWidth =
              2 * (t.lineWidth || h("markupLinesWidth", i) || 1) - 1),
            this.beginPath(),
            this.moveTo(Math.round(e - o / 2), Math.round(s - o / 2)),
            this.lineTo(Math.round(e + o / 2), Math.round(s + o / 2)),
            this.moveTo(Math.round(e + o / 2) - 1, Math.round(s - o / 2)),
            this.lineTo(Math.round(e - o / 2) - 1, Math.round(s + o / 2)),
            this.stroke(),
            (this.lineCap = "butt");
        },
      },
    },
    SL: {
      stone: {
        draw: function (t, i) {
          var e = i.getX(t.x),
            s = i.getY(t.y),
            o = i.stoneRadius;
          (this.fillStyle = t.c || l(i, t.x, t.y)),
            this.beginPath(),
            this.rect(e - o / 2, s - o / 2, o, o),
            this.fill();
        },
      },
    },
    SM: {
      stone: {
        draw: function (t, i) {
          var e = i.getX(t.x),
            s = i.getY(t.y),
            o = i.stoneRadius;
          (this.strokeStyle = t.c || l(i, t.x, t.y)),
            (this.lineWidth =
              2 * (t.lineWidth || h("markupLinesWidth", i) || 1)),
            this.beginPath(),
            this.arc(e - o / 3, s - o / 3, o / 6, 0, 2 * Math.PI, !0),
            this.stroke(),
            this.beginPath(),
            this.arc(e + o / 3, s - o / 3, o / 6, 0, 2 * Math.PI, !0),
            this.stroke(),
            this.beginPath(),
            this.moveTo(e - o / 1.5, s),
            this.bezierCurveTo(
              e - o / 1.5,
              s + o / 2,
              e + o / 1.5,
              s + o / 2,
              e + o / 1.5,
              s
            ),
            this.stroke();
        },
      },
    },
    outline: {
      stone: {
        draw: function (t, i) {
          t.alpha ? (this.globalAlpha = t.alpha) : (this.globalAlpha = 0.3),
            t.stoneStyle
              ? o.drawHandlers[t.stoneStyle].stone.draw.call(this, t, i)
              : i.stoneHandler.stone.draw.call(this, t, i),
            (this.globalAlpha = 1);
        },
      },
    },
    mini: {
      stone: {
        draw: function (t, i) {
          (i.stoneRadius = i.stoneRadius / 2),
            t.stoneStyle
              ? o.drawHandlers[t.stoneStyle].stone.draw.call(this, t, i)
              : i.stoneHandler.stone.draw.call(this, t, i),
            (i.stoneRadius = 2 * i.stoneRadius);
        },
      },
    },
  }),
    (o.coordinates = {
      grid: {
        draw: function (t, i) {
          var e, s, o, n, a, r;
          (this.fillStyle = h("coordinatesColor", i)),
            (this.textBaseline = "middle"),
            (this.textAlign = "center"),
            (this.font = i.stoneRadius + "px " + (i.font || "")),
            (o = i.getX(-0.75)),
            (n = i.getX(i.size - 0.25)),
            (a = i.getY(-0.75)),
            (r = i.getY(i.size - 0.25));
          for (var l = 0; l < i.size; l++)
            (e = l + "A".charCodeAt(0)) >= "I".charCodeAt(0) && e++,
              (s = i.getY(l)),
              this.fillText(i.size - l, o, s),
              this.fillText(i.size - l, n, s),
              (s = i.getX(l)),
              this.fillText(String.fromCharCode(e), s, a),
              this.fillText(String.fromCharCode(e), s, r);
          this.fillStyle = "black";
        },
      },
    }),
    (o.CanvasLayer = function () {
      (this.element = document.createElement("canvas")),
        (this.context = this.element.getContext("2d")),
        (this.pixelRatio = t.devicePixelRatio || 1),
        this.pixelRatio > 1 &&
          this.context.scale(this.pixelRatio, this.pixelRatio);
    }),
    (o.CanvasLayer.prototype = {
      constructor: o.CanvasLayer,
      setDimensions: function (t, i) {
        (this.element.width = t),
          (this.element.style.width = t / this.pixelRatio + "px"),
          (this.element.height = i),
          (this.element.style.height = i / this.pixelRatio + "px");
      },
      appendTo: function (t, i) {
        (this.element.style.position = "absolute"),
          (this.element.style.zIndex = i),
          t.appendChild(this.element);
      },
      removeFrom: function (t) {
        t.removeChild(this.element);
      },
      getContext: function () {
        return this.context;
      },
      draw: function (t) {},
      clear: function () {
        this.context.clearRect(0, 0, this.element.width, this.element.height);
      },
    }),
    (o.GridLayer = s.extendClass(o.CanvasLayer, function () {
      this.super.call(this);
    })),
    (o.GridLayer.prototype.draw = function (t) {
      var i;
      this.context.beginPath(),
        (this.context.lineWidth = h("gridLinesWidth", t)),
        (this.context.strokeStyle = h("gridLinesColor", t));
      var e = Math.round(t.left),
        s = Math.round(t.top),
        o = Math.round(t.fieldWidth * (t.size - 1)),
        n = Math.round(t.fieldHeight * (t.size - 1));
      this.context.strokeRect(e - t.ls, s - t.ls, o, n);
      for (var a = 1; a < t.size - 1; a++)
        (i = Math.round(t.getX(a)) - t.ls),
          this.context.moveTo(i, s),
          this.context.lineTo(i, s + n),
          (i = Math.round(t.getY(a)) - t.ls),
          this.context.moveTo(e, i),
          this.context.lineTo(e + o, i);
      if (
        (this.context.stroke(),
        (this.context.fillStyle = h("starColor", t)),
        t.starPoints[t.size])
      )
        for (var r in t.starPoints[t.size])
          this.context.beginPath(),
            this.context.arc(
              t.getX(t.starPoints[t.size][r].x) - t.ls,
              t.getY(t.starPoints[t.size][r].y) - t.ls,
              h("starSize", t),
              0,
              2 * Math.PI,
              !0
            ),
            this.context.fill();
    }),
    (o.MultipleCanvasLayer = s.extendClass(o.CanvasLayer, function () {
      this.init(4);
    })),
    (o.MultipleCanvasLayer.prototype.init = function (i) {
      var e, s;
      (this.layers = i),
        (this.elements = []),
        (this.contexts = []),
        (this.pixelRatio = t.devicePixelRatio || 1);
      for (var o = 0; o < i; o++)
        (s = (e = document.createElement("canvas")).getContext("2d")),
          this.pixelRatio > 1 && s.scale(this.pixelRatio, this.pixelRatio),
          this.elements.push(e),
          this.contexts.push(s);
    }),
    (o.MultipleCanvasLayer.prototype.appendTo = function (t, i) {
      for (var e = 0; e < this.layers; e++)
        (this.elements[e].style.position = "absolute"),
          (this.elements[e].style.zIndex = i),
          t.appendChild(this.elements[e]);
    }),
    (o.MultipleCanvasLayer.prototype.removeFrom = function (t) {
      for (var i = 0; i < this.layers; i++) t.removeChild(this.elements[i]);
    }),
    (o.MultipleCanvasLayer.prototype.getContext = function (t) {
      return t.x % 2
        ? t.y % 2
          ? this.contexts[0]
          : this.contexts[1]
        : t.y % 2
        ? this.contexts[2]
        : this.contexts[3];
    }),
    (o.MultipleCanvasLayer.prototype.clear = function (t, i) {
      for (var e = 0; e < this.layers; e++)
        this.contexts[e].clearRect(
          0,
          0,
          this.elements[e].width,
          this.elements[e].height
        );
    }),
    (o.MultipleCanvasLayer.prototype.setDimensions = function (t, i) {
      for (var e = 0; e < this.layers; e++)
        (this.elements[e].width = t),
          (this.elements[e].style.width = t / this.pixelRatio + "px"),
          (this.elements[e].height = i),
          (this.elements[e].style.height = i / this.pixelRatio + "px");
    }),
    (o.ShadowLayer = s.extendClass(o.MultipleCanvasLayer, function (t, i, e) {
      this.init(2), (this.shadowSize = void 0 === i ? 1 : i), (this.board = t);
    })),
    (o.ShadowLayer.prototype.getContext = function (t) {
      return !(t.x % 2 && t.y % 2) && (t.x % 2 || t.y % 2)
        ? this.contexts[1]
        : this.contexts[0];
    }),
    (o.ShadowLayer.prototype.setDimensions = function (t, i) {
      this.super.prototype.setDimensions.call(this, t, i);
      for (var e = 0; e < this.layers; e++)
        this.contexts[e].setTransform(
          1,
          0,
          0,
          1,
          Math.round((this.shadowSize * this.board.stoneRadius) / 7),
          Math.round((this.shadowSize * this.board.stoneRadius) / 7)
        );
    });
  var f = function (t, i) {
      var e = i.getX(t.x),
        s = i.getY(t.y),
        o = i.stoneRadius;
      this.clearRect(e - 2 * o - i.ls, s - 2 * o - i.ls, 4 * o, 4 * o);
    },
    p = function () {
      return (
        (3 * this.width) / (4 * (this.bx + 1 - this.tx) + 2) -
        this.fieldWidth * this.tx
      );
    },
    g = function () {
      return (
        (3 * this.height) / (4 * (this.by + 1 - this.ty) + 2) -
        this.fieldHeight * this.ty
      );
    },
    y = function () {
      return (4 * this.width) / (4 * (this.bx + 1 - this.tx) + 2);
    },
    x = function () {
      return (4 * this.height) / (4 * (this.by + 1 - this.ty) + 2);
    },
    m = function (t, i) {
      for (var e, s = 0; s < this.obj_arr[t][i].length; s++) {
        var n = this.obj_arr[t][i][s];
        for (var h in (e = n.type
          ? "string" == typeof n.type
            ? o.drawHandlers[n.type]
            : n.type
          : this.stoneHandler))
          e[h].clear
            ? e[h].clear.call(this[h].getContext(n), n, this)
            : f.call(this[h].getContext(n), n, this);
      }
    },
    v = function (t, i) {
      for (var e, s = 0; s < this.obj_arr[t][i].length; s++) {
        var n = this.obj_arr[t][i][s];
        for (var h in (e = n.type
          ? "string" == typeof n.type
            ? o.drawHandlers[n.type]
            : n.type
          : this.stoneHandler))
          e[h].draw.call(this[h].getContext(n), n, this);
      }
    },
    b = function () {
      (this.element.style.width = this.width / this.pixelRatio + "px"),
        (this.element.style.height = this.height / this.pixelRatio + "px"),
        (this.stoneRadius = h("stoneSize", this)),
        (this.ls = h("linesShift", this));
      for (var t = 0; t < this.layers.length; t++)
        this.layers[t].setDimensions(this.width, this.height);
    };
  (o.prototype = {
    constructor: o,
    init: function () {
      this.obj_arr = [];
      for (var t = 0; t < this.size; t++) {
        this.obj_arr[t] = [];
        for (var i = 0; i < this.size; i++) this.obj_arr[t][i] = [];
      }
      (this.obj_list = []),
        (this.layers = []),
        (this.listeners = []),
        (this.element = document.createElement("div")),
        (this.element.className = "wgo-board"),
        (this.element.style.position = "relative"),
        this.background &&
          ("#" == this.background[0]
            ? (this.element.style.backgroundColor = this.background)
            : ((this.element.style.backgroundImage =
                "url('" + this.background + "')"),
              this.stoneHandler == o.drawHandlers.REALISTIC &&
                (this.element.style.backgroundSize = "100%"))),
        (this.grid = new o.GridLayer()),
        (this.shadow = new o.ShadowLayer(this, h("shadowSize", this))),
        (this.stone = new o.MultipleCanvasLayer()),
        this.addLayer(this.grid, 100),
        this.addLayer(this.shadow, 200),
        this.addLayer(this.stone, 300);
    },
    setWidth: function (t) {
      (this.width = t),
        (this.width *= this.pixelRatio),
        (this.fieldHeight = this.fieldWidth = y.call(this)),
        (this.left = p.call(this)),
        (this.height = (this.by - this.ty + 1.5) * this.fieldHeight),
        (this.top = g.call(this)),
        b.call(this),
        this.redraw();
    },
    setHeight: function (t) {
      (this.height = t),
        (this.height *= this.pixelRatio),
        (this.fieldWidth = this.fieldHeight = x.call(this)),
        (this.top = g.call(this)),
        (this.width = (this.bx - this.tx + 1.5) * this.fieldWidth),
        (this.left = p.call(this)),
        b.call(this),
        this.redraw();
    },
    setDimensions: function (t, i) {
      (this.width = t || parseInt(this.element.style.width, 10)),
        (this.width *= this.pixelRatio),
        (this.height = i || parseInt(this.element.style.height, 10)),
        (this.height *= this.pixelRatio),
        (this.fieldWidth = y.call(this)),
        (this.fieldHeight = x.call(this)),
        (this.left = p.call(this)),
        (this.top = g.call(this)),
        b.call(this),
        this.redraw();
    },
    getSection: function () {
      return this.section;
    },
    setSection: function (t, i, e, s) {
      (this.section =
        "object" == typeof t ? t : { top: t, right: i, bottom: e, left: s }),
        (this.tx = this.section.left),
        (this.ty = this.section.top),
        (this.bx = this.size - 1 - this.section.right),
        (this.by = this.size - 1 - this.section.bottom),
        this.setDimensions();
    },
    setSize: function (t) {
      if ((t = t || 19) != this.size) {
        (this.size = t), (this.obj_arr = []);
        for (var i = 0; i < this.size; i++) {
          this.obj_arr[i] = [];
          for (var e = 0; e < this.size; e++) this.obj_arr[i][e] = [];
        }
        (this.bx = this.size - 1 - this.section.right),
          (this.by = this.size - 1 - this.section.bottom),
          this.setDimensions();
      }
    },
    redraw: function () {
      try {
        for (var t = 0; t < this.layers.length; t++)
          this.layers[t].clear(this), this.layers[t].draw(this);
        for (t = 0; t < this.size; t++)
          for (var i = 0; i < this.size; i++) v.call(this, t, i);
        for (t = 0; t < this.obj_list.length; t++) {
          var e = this.obj_list[t],
            s = e.handler;
          for (var o in s)
            s[o].draw.call(this[o].getContext(e.args), e.args, this);
        }
      } catch (t) {
        console.log("WGo board failed to render. Error: " + t.message);
      }
    },
    getX: function (t) {
      return this.left + t * this.fieldWidth;
    },
    getY: function (t) {
      return this.top + t * this.fieldHeight;
    },
    addLayer: function (t, i) {
      t.appendTo(this.element, i),
        t.setDimensions(this.width, this.height),
        this.layers.push(t);
    },
    removeLayer: function (t) {
      var i = this.layers.indexOf(t);
      i >= 0 && (this.layers.splice(i, 1), t.removeFrom(this.element));
    },
    update: function (t) {
      var i;
      if (t.remove && "all" == t.remove) this.removeAllObjects();
      else if (t.remove)
        for (i = 0; i < t.remove.length; i++) this.removeObject(t.remove[i]);
      if (t.add) for (i = 0; i < t.add.length; i++) this.addObject(t.add[i]);
    },
    addObject: function (t) {
      if (t.constructor != Array)
        try {
          m.call(this, t.x, t.y);
          for (var i = this.obj_arr[t.x][t.y], e = 0; e < i.length; e++)
            if (i[e].type == t.type)
              return (i[e] = t), void v.call(this, t.x, t.y);
          t.type ? i.push(t) : i.unshift(t), v.call(this, t.x, t.y);
        } catch (t) {
          console.log("WGo board failed to render. Error: " + t.message);
        }
      else for (var s = 0; s < t.length; s++) this.addObject(t[s]);
    },
    removeObject: function (t) {
      if (t.constructor != Array)
        try {
          for (var i, e = 0; e < this.obj_arr[t.x][t.y].length; e++)
            if (this.obj_arr[t.x][t.y][e].type == t.type) {
              i = e;
              break;
            }
          if (void 0 === i) return;
          m.call(this, t.x, t.y),
            this.obj_arr[t.x][t.y].splice(i, 1),
            v.call(this, t.x, t.y);
        } catch (t) {
          console.log("WGo board failed to render. Error: " + t.message);
        }
      else for (var s = 0; s < t.length; s++) this.removeObject(t[s]);
    },
    removeObjectsAt: function (t, i) {
      this.obj_arr[t][i].length &&
        (m.call(this, t, i), (this.obj_arr[t][i] = []));
    },
    removeAllObjects: function () {
      this.obj_arr = [];
      for (var t = 0; t < this.size; t++) {
        this.obj_arr[t] = [];
        for (var i = 0; i < this.size; i++) this.obj_arr[t][i] = [];
      }
      this.redraw();
    },
    addCustomObject: function (t, i) {
      this.obj_list.push({ handler: t, args: i }), this.redraw();
    },
    removeCustomObject: function (t, i) {
      for (var e = 0; e < this.obj_list.length; e++) {
        var s = this.obj_list[e];
        if (s.handler == t && s.args == i)
          return this.obj_list.splice(e, 1), this.redraw(), !0;
      }
      return !1;
    },
    addEventListener: function (t, i) {
      var e = this,
        s = {
          type: t,
          callback: i,
          handleEvent: function (t) {
            var s = function (t) {
              var i, e;
              return (
                (i = t.offsetX * this.pixelRatio),
                (i -= this.left),
                (i /= this.fieldWidth),
                (i = Math.round(i)),
                (e = t.offsetY * this.pixelRatio),
                (e -= this.top),
                (e /= this.fieldHeight),
                (e = Math.round(e)),
                { x: i >= this.size ? -1 : i, y: e >= this.size ? -1 : e }
              );
            }.call(e, t);
            i(s.x, s.y, t);
          },
        };
      this.element.addEventListener(t, s, !0), this.listeners.push(s);
    },
    removeEventListener: function (t, i) {
      for (var e = 0; e < this.listeners.length; e++) {
        var s = this.listeners[e];
        if (s.type == t && s.callback == i)
          return (
            this.element.removeEventListener(s.type, s, !0),
            this.listeners.splice(e, 1),
            !0
          );
      }
      return !1;
    },
    getState: function () {
      return { objects: s.clone(this.obj_arr), custom: s.clone(this.obj_list) };
    },
    restoreState: function (t) {
      (this.obj_arr = t.objects || this.obj_arr),
        (this.obj_list = t.custom || this.obj_list),
        this.redraw();
    },
  }),
    (o.default = {
      size: 19,
      width: 0,
      height: 0,
      font: "Calibri",
      lineWidth: 1,
      autoLineWidth: !1,
      starPoints: {
        5: [{ x: 2, y: 2 }],
        7: [{ x: 3, y: 3 }],
        8: [
          { x: 2, y: 2 },
          { x: 5, y: 2 },
          { x: 2, y: 5 },
          { x: 5, y: 5 },
        ],
        9: [
          { x: 2, y: 2 },
          { x: 6, y: 2 },
          { x: 4, y: 4 },
          { x: 2, y: 6 },
          { x: 6, y: 6 },
        ],
        10: [
          { x: 2, y: 2 },
          { x: 7, y: 2 },
          { x: 2, y: 7 },
          { x: 7, y: 7 },
        ],
        11: [
          { x: 2, y: 2 },
          { x: 8, y: 2 },
          { x: 5, y: 5 },
          { x: 2, y: 8 },
          { x: 8, y: 8 },
        ],
        12: [
          { x: 3, y: 3 },
          { x: 8, y: 3 },
          { x: 3, y: 8 },
          { x: 8, y: 8 },
        ],
        13: [
          { x: 3, y: 3 },
          { x: 9, y: 3 },
          { x: 6, y: 6 },
          { x: 3, y: 9 },
          { x: 9, y: 9 },
        ],
        14: [
          { x: 3, y: 3 },
          { x: 10, y: 3 },
          { x: 3, y: 10 },
          { x: 10, y: 10 },
        ],
        15: [
          { x: 3, y: 3 },
          { x: 11, y: 3 },
          { x: 7, y: 7 },
          { x: 3, y: 11 },
          { x: 11, y: 11 },
        ],
        16: [
          { x: 3, y: 3 },
          { x: 12, y: 3 },
          { x: 3, y: 12 },
          { x: 12, y: 12 },
        ],
        17: [
          { x: 3, y: 3 },
          { x: 8, y: 3 },
          { x: 13, y: 3 },
          { x: 3, y: 8 },
          { x: 8, y: 8 },
          { x: 13, y: 8 },
          { x: 3, y: 13 },
          { x: 8, y: 13 },
          { x: 13, y: 13 },
        ],
        18: [
          { x: 3, y: 3 },
          { x: 14, y: 3 },
          { x: 3, y: 14 },
          { x: 14, y: 14 },
        ],
        19: [
          { x: 3, y: 3 },
          { x: 9, y: 3 },
          { x: 15, y: 3 },
          { x: 3, y: 9 },
          { x: 9, y: 9 },
          { x: 15, y: 9 },
          { x: 3, y: 15 },
          { x: 9, y: 15 },
          { x: 15, y: 15 },
        ],
        20: [
          { x: 3, y: 3 },
          { x: 16, y: 3 },
          { x: 3, y: 16 },
          { x: 16, y: 16 },
        ],
        21: [
          { x: 3, y: 3 },
          { x: 10, y: 3 },
          { x: 17, y: 3 },
          { x: 3, y: 10 },
          { x: 10, y: 10 },
          { x: 17, y: 10 },
          { x: 3, y: 17 },
          { x: 10, y: 17 },
          { x: 17, y: 17 },
        ],
      },
      stoneHandler: o.drawHandlers.REALISTIC,
      starSize: 1,
      shadowSize: 1,
      stoneSize: 1,
      section: { top: 0, right: 0, bottom: 0, left: 0 },
      background: s.DIR + "wgo/wood_1024.png",
      whiteStoneGraphic: [s.DIR + "wgo/white_64.png"],
      blackStoneGraphic: [s.DIR + "wgo/black_64.png"],
      theme: {},
    }),
    (s.Board = o);
  var w = function (t) {
    (this.size = t || 19), (this.schema = []);
    for (var i = 0; i < this.size * this.size; i++) this.schema[i] = 0;
  };
  (w.prototype = {
    constructor: s.Position,
    get: function (t, i) {
      if (!(t < 0 || i < 0 || t >= this.size || i >= this.size))
        return this.schema[t * this.size + i];
    },
    set: function (t, i, e) {
      return (this.schema[t * this.size + i] = e), this;
    },
    clear: function () {
      for (var t = 0; t < this.size * this.size; t++) this.schema[t] = 0;
      return this;
    },
    clone: function () {
      var t = new w(this.size);
      return (t.schema = this.schema.slice(0)), t;
    },
    compare: function (t) {
      for (var i = [], e = [], s = 0; s < this.size * this.size; s++)
        this.schema[s] && !t.schema[s]
          ? e.push({ x: Math.floor(s / this.size), y: s % this.size })
          : this.schema[s] != t.schema[s] &&
            i.push({
              x: Math.floor(s / this.size),
              y: s % this.size,
              c: t.schema[s],
            });
      return { add: i, remove: e };
    },
  }),
    (s.Position = w);
  var C = function (t, i, e, o) {
      (this.size = t || 19),
        (this.repeating = void 0 === i ? "KO" : i),
        (this.allow_rewrite = e || !1),
        (this.allow_suicide = o || !1),
        (this.stack = []),
        (this.stack[0] = new w(this.size)),
        (this.stack[0].capCount = { black: 0, white: 0 }),
        (this.turn = s.B),
        Object.defineProperty(this, "position", {
          get: function () {
            return this.stack[this.stack.length - 1];
          },
          set: function (t) {
            this.stack[this.stack.length - 1] = t;
          },
        });
    },
    S = function (t, i, e, s, o) {
      e >= 0 &&
        e < t.size &&
        s >= 0 &&
        s < t.size &&
        t.get(e, s) == o &&
        (t.set(e, s, 0),
        i.push({ x: e, y: s }),
        S(t, i, e, s - 1, o),
        S(t, i, e, s + 1, o),
        S(t, i, e - 1, s, o),
        S(t, i, e + 1, s, o));
    },
    k = function (t, i, e, s, o) {
      return (
        e < 0 ||
        e >= t.size ||
        s < 0 ||
        s >= t.size ||
        (0 != t.get(e, s) &&
          (1 == i.get(e, s) ||
            t.get(e, s) == -o ||
            (i.set(e, s, !0),
            k(t, i, e, s - 1, o) &&
              k(t, i, e, s + 1, o) &&
              k(t, i, e - 1, s, o) &&
              k(t, i, e + 1, s, o))))
      );
    },
    R = function (t, i, e, s) {
      var o = [];
      if (i >= 0 && i < t.size && e >= 0 && e < t.size && t.get(i, e) == s) {
        var n = new w(t.size);
        k(t, n, i, e, s) && S(t, o, i, e, s);
      }
      return o;
    };
  (C.prototype = {
    constructor: C,
    getPosition: function () {
      return this.stack[this.stack.length - 1];
    },
    play: function (t, i, e, o) {
      if (!this.isOnBoard(t, i)) return 1;
      if (!this.allow_rewrite && 0 != this.position.get(t, i)) return 2;
      e || (e = this.turn);
      var n = this.position.clone();
      n.set(t, i, e);
      var h = e,
        a = R(n, t - 1, i, -e).concat(
          R(n, t + 1, i, -e),
          R(n, t, i - 1, -e),
          R(n, t, i + 1, -e)
        );
      if (!a.length) {
        var r = new w(this.size);
        if (k(n, r, t, i, e)) {
          if (!this.allow_suicide) return 3;
          (h = -e), S(n, a, t, i, e);
        }
      }
      return this.repeating &&
        !function (t, i, e) {
          var s, o;
          if ("KO" == this.repeating && this.stack.length - 2 >= 0)
            o = this.stack.length - 2;
          else {
            if ("ALL" != this.repeating) return !0;
            o = 0;
          }
          for (var n = this.stack.length - 2; n >= o; n--)
            if (this.stack[n].get(i, e) == t.get(i, e)) {
              s = !0;
              for (var h = 0; h < this.size * this.size; h++)
                if (this.stack[n].schema[h] != t.schema[h]) {
                  s = !1;
                  break;
                }
              if (s) return !1;
            }
          return !0;
        }.call(this, n, t, i)
        ? 4
        : !o &&
            ((n.color = e),
            (n.capCount = {
              black: this.position.capCount.black,
              white: this.position.capCount.white,
            }),
            h == s.B
              ? (n.capCount.black += a.length)
              : (n.capCount.white += a.length),
            this.pushPosition(n),
            (this.turn = -e),
            a);
    },
    pass: function (t) {
      this.pushPosition(),
        t
          ? ((this.position.color = t), (this.turn = -t))
          : ((this.position.color = this.turn), (this.turn = -this.turn));
    },
    isValid: function (t, i, e) {
      return "number" != typeof this.play(t, i, e, !0);
    },
    isOnBoard: function (t, i) {
      return t >= 0 && i >= 0 && t < this.size && i < this.size;
    },
    addStone: function (t, i, e) {
      return (
        !(!this.isOnBoard(t, i) || 0 != this.position.get(t, i)) &&
        (this.position.set(t, i, e || 0), !0)
      );
    },
    removeStone: function (t, i) {
      return (
        !(!this.isOnBoard(t, i) || 0 == this.position.get(t, i)) &&
        (this.position.set(t, i, 0), !0)
      );
    },
    setStone: function (t, i, e) {
      return !!this.isOnBoard(t, i) && (this.position.set(t, i, e || 0), !0);
    },
    getStone: function (t, i) {
      return this.isOnBoard(t, i) ? this.position.get(t, i) : 0;
    },
    pushPosition: function (t) {
      t ||
        (((t = this.position.clone()).capCount = {
          black: this.position.capCount.black,
          white: this.position.capCount.white,
        }),
        (t.color = this.position.color));
      return this.stack.push(t), t.color && (this.turn = -t.color), this;
    },
    popPosition: function () {
      var t = null;
      return (
        this.stack.length > 0 &&
          ((t = this.stack.pop()),
          0 == this.stack.length
            ? (this.turn = s.B)
            : this.position.color
            ? (this.turn = -this.position.color)
            : (this.turn = -this.turn)),
        t
      );
    },
    firstPosition: function () {
      return (
        (this.stack = []),
        (this.stack[0] = new w(this.size)),
        (this.stack[0].capCount = { black: 0, white: 0 }),
        (this.turn = s.B),
        this
      );
    },
    getCaptureCount: function (t) {
      return t == s.B
        ? this.position.capCount.black
        : this.position.capCount.white;
    },
    validatePosition: function () {
      for (
        var t, i, e = 0, o = 0, n = [], h = this.position.clone(), a = 0;
        a < this.size;
        a++
      )
        for (var r = 0; r < this.size; r++)
          (t = this.position.get(a, r)) &&
            ((i = n.length),
            (n = n.concat(
              R(h, a - 1, r, -t),
              R(h, a + 1, r, -t),
              R(h, a, r - 1, -t),
              R(h, a, r + 1, -t)
            )),
            t == s.B ? (o += n - i) : (e += n - i));
      return (
        (this.position.capCount.black += o),
        (this.position.capCount.white += e),
        (this.position.schema = h.schema),
        n
      );
    },
  }),
    (s.Game = C),
    (t.WGo = s);
})(window);
